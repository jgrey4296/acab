
type.check.rule:
    // get all typing rules
    applicable.$rules(::rule.typing, λcollect)?
    ᛦ $types(::type.def, λcollect)?
    // DFS and run them on each node

    ᛦ $x(λsieve $rules)
end


a.type(::type.product):
    | $x |
    #typeclass.a
    #typeclass.b

    $x.y.z(::a)?
    $x.a.b(::b)?

    // implicit assert $x(::a.type)
end

b.type(::type.sum):
    | $x |
    #sieve
    $x.a.$y(::t)?
    $x.b.$y(::t2)?
    $x.c.$y(::t3)?

    // implicit assert $x(::b.type)
end

typing.nominal.rule:
    | $x |
    $x(::$def_sen)?
    $def_sen [ λtail $the_def(::type.sum) ] ?
    $x ∈ $the_def?
end

typing.structural.rule:
    | $x |

    // $x has a typedef
    $x(::$def_sen)?
    ~$typedef(== ATOM)?
    // $typedef is a type
    // maybe aggregate all typedefs *along this path*?
    $def_sen [λtail $the_def(::type.product)] ?

    // Union the node against the definition
    λapply $the_def.on.$x -> $gamma'

    λtype.apply gamma'
end

typing.sum.rule:
    | $x |

    $x(::typedef)?
    $typdef(λtail $y(::type.sum))?

    // internally has a ∪ for structure when hitting a sum.product
    $x ∈ $y -> $updates

    λtype.apply $updates
end

typing.operator.rule:
    | $x |

    $x(::production.component)?
    $x.operator!$op(::sen)?
    $x.args.$b?
    $x.return!$c?

    $op(λtail $ao(::operator))?
    $ao.params.$aop.return.$aor?

    $b ∪ $aop -> $updates
    $c ∪ $aor -> $updates'

    λtype.apply $updates $updates'
end

typing.container.rule:
    | $x |

    $x(::container)?
    $x.clauses.$y(λcollect $y)?

    λcheck $y -> $updates

    λapply $updates
end

type.class.rule:
    | $x |

    $x(::$typedef)?
    $typedef(λtail $def)?
    $def(:∈:a.type.class)?
end
