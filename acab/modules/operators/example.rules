operators:
    action:
        λa.b.c $x
        ! $y
    end
    causal:
        a.b.$x(::DAG)?
        $x.action.$y?

        λdo $y in $x -> $prob

        λdo $y in $x
    end
    conflict:
        a.$action(::Action)?
        b.$other(::Action, ∩ $action)?

        λconflict $action $other
    end
    defeasibility:
        a.rule.$x?
        a.rule.$y(~$x)?

        $x defeats $y
    end
    delta:
        a.value.$x(::delta)?

        + $x
        - $x
    end
    dfs:
        $x ᛦ $y(::X)?
    end
    interleave:
        a.b.$x(::action, collect)?
        a.c.$y(::action, collect)?

        λsort $x -> $xs
        λsort $y -> $ys
        λmix $xs $ys -> $xys
    end
    collection:
        // queue and stack and set?
        $x(∈ $y)?

        λpop $y -> $z

        λpush $x
    end
    pattern_match:
        λmatch $x:
            $x(::A) -> $y
            $x(> 2) -> $z
            $_      -> error
        end
    end
    pipeline:
        a.b.$x(::layer)?

        λrun $x
        loop(count 5):
            ~a.b.blah?

            λrun $x
        end
        λrun $x
    end
    layer:
        a.b.$x(::rule)?
        an.$agenda?

        λrun.proxy $x -> $ctxs
        λrun.forall $agenda $ctxs -> $ctxs'

        λrun.proxy $ctxs'
    end
    agenda:
        | $ins |
        \\ Run for each specific context instance
        $ins.rule.$r(#blah)?
        $x?

        λpass | λfail
    end
    query:
        a.b.$x(::A, > $y, ~= /blah/)?
    end
    substruct:
        a.b.$x(::Node, ^field : blah)?
    end
    transform:
        $x + $y -> $z
    end
